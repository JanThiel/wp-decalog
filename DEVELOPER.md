# Developing for DecaLog

Before starting to explain how to use DecaLog from a developer point of view, I would like to thank you to take the time to invest your knowledge and skills in making DecaLog better and more useful. I'll only have one word: you rock! (OK, that's two words)

Now, what's the menu today?

1. [What is DecaLog?](#what-is-decalog)
2. [Definitions](#definitions)
3. [Architecture of DecaLog](#architecture-of-decalog)
4. [Anatomy of an event](#anatomy-of-an-event)
5. [Coding with DecaLog](#coding-with-decalog)
6. [Conventions](#conventions)
7. [Contribution Guidelines](/CONTRIBUTING.md)
8. [Code of Conduct](/CODE_OF_CONDUCT.md)

## What is DecaLog?
DecaLog is WordPress plugin which aims to:
- capture events generated by the core of WordPress and themes / plugins;
- enrich these events with many details regarding their triggering;
- record these events in the WordPress database and/or send them to external services for logging, monitoring and alerting;
- view (and filter) events recorded in the WordPress database.

## Definitions
When using (and developing for) DecaLog, you will have to deal with the following notions:
- __Event__ - An event is some bits of information regarding something which hapened while executing WordPress. See [Anatomy of an event](#anatomy-of-an-event) to know what it's made of.
- __Listener__ - A listener is, as its name suggests, something that listens to what's going on in a specific _perimeter_ (mainly a specific WordPress component or subsystem), make it an ___event___ and pass this ___event___ to the running ___loggers___.
- __Logger__ - A logger is a _recorder_ of events. It can filter them (accept or refuse to record the event based on settings) then store them (in a database, a file, etc.) or send them (via API calls, sockets, mails, etc.).

## Architecture of DecaLog

## Anatomy of an event
An ___event___ is composed of:
- A __channel__, which is the type of execution that triggered the event. It is automatically detected (and filled) by DecaLog and it can take the following values: `CLI` (command-line interface), `CRON` (cron job), `AJAX` (Ajax request), `XMLRPC` (XML-RPC request), `API` (Rest API request), `FEED` (Atom/RDF/RSS feed), `WBACK` (site backend), `WFRONT` (site frontend).
- A __level__, which represents the severity of the event. This level is set by the listener, regarding what triggered the event. It can take the following values (from the lowest severity to the highest): `DEBUG`, `INFO`, `NOTICE`, `WARNING`, `ERROR`, `CRITICAL`, `ALERT`, `EMERGENCY`. For a detail on how it is used, please read "Events standards" in [Conventions](#conventions).
- A __timestamp__, which is the time when event was triggered.
- A versioned __source__, which is the component or the subsystem where the event is triggered. It maybe things like `PHP`/`7.2` or `WordPress`/`5.2.2` and so on...
- The __class__ of the source, which can take the following values: `core`, `plugin`, `theme`, `db`, `php`.
- A __message__ in plain text.
- An numerical __code__, which may be everything which makes sense regarding the event (an error code, for instance).

Depending on each loggers settings, an ___event___ may contains many other fields which are automaticaly detected and filled by DecaLog.


## Coding with DecaLog
In fact, as a developer, you will have to deal only with ___level___, ___message___ and ___code___. All other fields of the event being handled internaly by DecaLog.

### Simple usage
The simplest way to generate an event from your code is to use DecaLog as a standard PSR-3 logger. You can do so as soon as all code for `plugins_loaded` WordPress hook is executed.
```php
    use Decalog\Log;
    
    // Initializes the main events logger
    $event_logger = Log::bootstrap( 'plugin', 'My Plugin', '1.2.3' );
    
    // Logs a debug message
    $event_logger->debug( 'Test message.' );
    
    // Logs an error with an optional error code
    $event_logger->error( 'Test message.', 404 );

```

This way of doing things is quite operational but, to be honest, there is a much, much, better way: writing your own listener!

### Writing a listener
As previously said, a ___listener___ is a piece of code which listens to a specific _perimeter_. You can write a listener just for your plugin or theme. If your listener respects [conventions](#conventions) and if your plugin or theme is present in the WordPress directory, it can be released with the next version of DecaLog.

Before writing a ___listener___ your plugin or theme must define actions hooks with `do_action()` function each time a significant event occurs. Like this:

```php
    /**
    * Fires immediately after a content is deleted.
    *
    * @since 4.4.0
    *
    * @param string $content_id  ID of the deleted content.
    */
    do_action( 'myplugin_delete_content', $content_id );     
```

Once done, you can write your ___listener___ by extending the class `Decalog\Listener\AbstractListener` and put your file in `./wp-content/plugins/decalog/includes/listeners/`. Your listener class must implement the three following abstract methods:
- `init()` to set the class parameters;
- `is_available()` to verify if your plugin or theme is installed and activated;
- `launch()` to "launch" the listener.

Here is an example which implements a simple ___listener___ able to listen the action defined sooner in this section:

```php
    /**
     * My Plugin listener for DecaLog.
     *
     * Defines methods and properties for My Plugin listener class.
     *
     * @package Listeners
     * @author  Me <me@mail.com>.
     * @since   1.0.0
     */
    class MypluginListener extends AbstractListener {
    
        /**
         * Sets the listener properties.
         *
         * @since    1.0.0
         */
        protected function init() {
            $this->id      = 'my-plugin-slug';
            $this->name    = 'My wonderful plugin';
            $this->class   = 'plugin';
            $this->product = 'My Plugin';
            if ( defined( 'MYPLUGIN_VERSION') ) {
                $this->version = MYPLUGIN_VERSION;
            } else {
                $this->version = 'x';
            }
        }
    
        /**
         * Verify if this listener is needed, mainly by verifying if the listen plugin/theme is loaded.
         *
         * @return  boolean     True if listener is needed, false otherwise.
         * @since    1.0.0
         */
        protected function is_available() {
            return defined( 'MYPLUGIN_VERSION') && class_exists ( 'MyPluginClass' );
        }
    
        /**
         * "Launch" the listener.
         *
         * @return  boolean     True if listener was launched, false otherwise.
         * @since    1.0.0
         */
        protected function launch() {
            // Attachments.
            add_action( 'myplugin_delete_content', [ $this, 'delete_content' ], 10, 1 );
            return true;
        }
    
        /**
         * "add_attachment" event.
         *
         * @since    1.0.0
         */
        public function delete_content( $content_ID ) {
            $this->logger->info( sprintf ( 'Content ID $s deleted', $content_ID ) );
        }
    
    }  
```

## Conventions

### General rules
versions

### Events standards

### Privacy

### Coding style
